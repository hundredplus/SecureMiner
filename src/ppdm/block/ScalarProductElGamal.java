
package ppdm.block;

import java.math.BigInteger;
import java.util.ArrayList;
import ppdm.core.crypto.ElGamal;
import ppdm.core.crypto.ElGamalCipherText;

/**
 *
 * @author Tran Huy Duc
 *
 * @date Sep 16, 2009
 */
public class ScalarProductElGamal {

    public ArrayList<ElGamalCipherText> computeSSP(ElGamal elGamal, ArrayList<BigInteger> myPrivateData,
            ArrayList<ElGamalCipherText> receivedData, boolean lastParty) {
        
        BigInteger[] privateData = new BigInteger[myPrivateData.size()];
        for (int i=0; i<privateData.length;i++){
            privateData[i] = myPrivateData.get(i);
        }
        ElGamalCipherText[] data;
        if (receivedData == null || receivedData.isEmpty())
            data = null;
        else{
            data = new ElGamalCipherText[receivedData.size()];
            for (int i = 0; i < data.length; i++) {
                data[i] = receivedData.get(i);
            }
        }
        ElGamalCipherText[] ret         = computeSSP(elGamal, privateData, data, lastParty);
        ArrayList<ElGamalCipherText> res = new ArrayList<ElGamalCipherText>();
        for (int i=0; i<ret.length;i++){
            res.add(ret[i]);
        }
        return res;
    }

    /**
     *
     * @param elGamal
     * @param myPrivateData
     * @param receivedData
     * @param lastParty
     * @return the encrypted value(s)
     */
    public ElGamalCipherText[] computeSSP(ElGamal elGamal, BigInteger[] myPrivateData,
            ElGamalCipherText[] receivedData, boolean lastParty){
        
        ElGamalCipherText[]    res;
        if (lastParty){            
            if (receivedData == null) {
                res = new ElGamalCipherText[1];
                BigInteger tmp = new BigInteger("0");
                for (int i = 0; i < myPrivateData.length; i++) {
                    tmp = tmp.add(myPrivateData[i]);
                }
                res[0] = elGamal.encrypt(tmp);
            } else {
                //To-Do: later version: need to have permutation here for security
                res = new ElGamalCipherText[myPrivateData.length];
                //encrypt local data
                ElGamalCipherText[] localData = elGamal.encrypt(myPrivateData);
                //compute the SSP
                for (int i = 0; i < receivedData.length; i++){
                    res[i] = receivedData[i].multiply(localData[i], elGamal.p);
                }
            }
        }else{
            res = new ElGamalCipherText[myPrivateData.length];
            if (receivedData == null){
                res = elGamal.encrypt(myPrivateData);
            }else{
                //encrypt local data
                ElGamalCipherText[] localData = elGamal.encrypt(myPrivateData);
                //compute the SSP
                for (int i = 0; i < receivedData.length; i++){
                    res[i] = receivedData[i].multiply(localData[i], elGamal.p);
                }
            }
        }
        return res;
    }


/*
    public BigInteger m_encSSP = new BigInteger("1",10);
    public BigInteger m_portion;
    public void calcualte(BigInteger[] receivedVector, BigInteger n, BigInteger g ){
        AutoGenerateData agd = new AutoGenerateData(receivedVector.length);
        for (int i=0; i< receivedVector.length; i++){
            m_encSSP = (m_encSSP.multiply(receivedVector[i].modPow(agd.getPrivateVectorData()[i],n.pow(2)))).mod(n.pow(2));
//            m_encSSP = m_encSSP.mod(n);
        }

        Random random = new Random();
        m_portion = new BigInteger(Integer.toString(random.nextInt(receivedVector.length)));

        Paillier pail = new Paillier(n, g);
        m_encSSP = (m_encSSP.multiply(pail.encrypt((n.pow(2)).subtract(m_portion)))).mod(n.pow(2));
//        m_encSSP = m_encSSP.mod(n);
    }

 */

}
